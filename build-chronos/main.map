{"version":3,"sources":["webpack:///webpack/bootstrap ead21ce95d5b7b27d643","webpack:///./chronos/models/db.js","webpack:///./shared/bull/create-queue.js","webpack:///external \"debug\"","webpack:///external \"raven\"","webpack:///./chronos/queues/constants.js","webpack:///./chronos/index.js","webpack:///./chronos/queues/send-weekly-digest-email.js","webpack:///external \"lodash.intersection\"","webpack:///external \"bull\"","webpack:///./chronos/models/thread.js","webpack:///external \"fs\"","webpack:///external \"path\"","webpack:///./cacert","webpack:///external \"rethinkdbdash\"","webpack:///./chronos/models/usersSettings.js","webpack:///./chronos/models/usersChannels.js","webpack:///./chronos/models/usersCommunities.js","webpack:///./chronos/models/message.js","webpack:///./chronos/models/community.js","webpack:///./chronos/jobs/index.js","webpack:///./chronos/jobs/utils.js","webpack:///./chronos/node_modules/cron/lib/cron.js","webpack:///external \"moment-timezone\"","webpack:///./shared/bull/create-worker.js","webpack:///external \"http\""],"names":["fs","require","path","IS_PROD","process","env","FORCE_DEV","DEFAULT_CONFIG","db","PRODUCTION_CONFIG","password","COMPOSE_RETHINKDB_PASSWORD","host","COMPOSE_RETHINKDB_URL","port","COMPOSE_RETHINKDB_PORT","ssl","ca","config","r","module","exports","Queue","Raven","environment","NODE_ENV","install","redis","COMPOSE_REDIS_PORT","COMPOSE_REDIS_URL","COMPOSE_REDIS_PASSWORD","undefined","options","createQueue","name","queue","on","job","message","id","console","error","captureException","Error","MIN_TOTAL_MESSAGE_COUNT","MIN_NEW_MESSAGE_COUNT","MAX_THREAD_COUNT_PER_CHANNEL","MIN_THREADS_REQUIRED_FOR_DIGEST","MAX_THREAD_COUNT_PER_DIGEST","COMMUNITY_UPSELL_THRESHOLD","TOTAL_MESSAGE_COUNT_WEIGHT","NEW_MESSAGE_COUNT_WEIGHT","SEND_WEEKLY_DIGEST_EMAIL","debug","createWorker","PORT","log","server","listen","address","sendWeeklyDigestEmailQueue","allActiveThreadsThisWeek","threadIds","length","messageCountPromises","map","communityId","channelId","content","thread","title","newMessageCount","totalMessageCount","messageCounts","Promise","all","filteredTopThreads","filter","activeThreadsByChannel","topThreads","obj","getCommunity","topThreadsWithCommunityDataPromises","community","slug","profilePhoto","threadId","threadsWithCommunityData","finalThreads","finishedTopThreads","eligibleUsersForWeeklyDigest","users","channelConnectionPromises","email","firstName","userId","user","channels","usersWithChannels","threadData","threadChannelKeys","Object","keys","getIntersectingChannels","e","rawThreadsForUsersEmail","arr","c","push","threads","threadsWithScores","score","sort","a","b","slice","processSendWeeklyDigests","eligibleUsers","topCommunities","sendDigestPromises","usersCommunityIds","communities","indexOf","add","catch","err","getActiveThreadsInPastWeek","table","row","during","now","sub","not","hasFields","run","getUsersForWeeklyDigest","eq","eqJoin","zip","pluck","distinct","getUsersChannelsEligibleForWeeklyDigest","getAll","index","isMember","getUsersCommunityIds","then","getTotalMessageCount","count","getNewMessageCount","getCommunityById","get","getTopCommunities","amount","communityIds","data","sortedCommunities","x","y","weeklyDigest","CronJob","addQueue","opts","worker","createJob","pattern","start","cronTime","onTick","removeOnComplete","removeOnFail","timeZone","http","sumArr","input","prop","reduce","sum","item","queueMap","queues","createServer","req","res","setHeader","getJobCounts","jobCounts","waiting","active","completed","failed","delayed","end","JSON","stringify"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA,sCAAsC,IAAI;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA,QAAQ,sBAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC;;;;;;;AC3hBD,4C;;;;;;;;;ACCA;AACA;AACA,MAAM+C,OAAO,mBAAA3K,CAAQ,EAAR,CAAb;AACA,MAAMgC,cAAc,mBAAAhC,CAAQ,CAAR,CAApB;;AAEA;;;;;;AAMA;AACA;AACA,MAAM4K,SAAS,CACbC,KADa,CACP;AADO,EAEbC,IAFa,CAER,aAFQ,CAEM;AAFN,KAGV;AACH,SAAOD,MAAME,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,KAAeD,MAAMC,KAAKH,IAAL,CAAlC,EAA8C,CAA9C,CAAP;AACD,CALD;;AAOA,MAAMzH,eAAe,CAAC6H,QAAD,CAAU,eAAV,KAA8B;AACjD;AACA,QAAMC,SAAS/E,OAAOC,IAAP,CAAY6E,QAAZ,EAAsBlH,GAAtB,CAA0B/B,QAAQ;AAC/C,UAAMC,QAAQF,YAAYC,IAAZ,CAAd;AACAC,UAAM/B,OAAN,CAAc+K,SAASjJ,IAAT,CAAd;AACA,WAAOC,KAAP;AACD,GAJc,CAAf;;AAMA,SAAOyI,KAAKS,YAAL,CAAkB,CAACC,GAAD,EAAMC,GAAN,KAAc;AACrCA,QAAIC,SAAJ,CAAc,cAAd,EAA8B,kBAA9B;AACA;AACA9G,YAAQC,GAAR,CAAYyG,OAAOnH,GAAP,CAAW9B,SAASA,MAAMsJ,YAAN,EAApB,CAAZ,EAAuDvC,IAAvD,CAA4DwC,aAAa;AACvE,YAAM/B,OAAO;AACXgC,iBAASd,OAAOa,SAAP,EAAkB,SAAlB,CADE;AAEXE,gBAAQf,OAAOa,SAAP,EAAkB,QAAlB,CAFG;AAGXG,mBAAWhB,OAAOa,SAAP,EAAkB,WAAlB,CAHA;AAIXI,gBAAQjB,OAAOa,SAAP,EAAkB,QAAlB,CAJG;AAKXK,iBAASlB,OAAOa,SAAP,EAAkB,SAAlB;AALE,OAAb;;AAQAH,UAAIS,GAAJ,CAAQC,KAAKC,SAAL,CAAevC,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAAR;AACD,KAVD;AAWD,GAdM,CAAP;AAeD,CAvBD;;AAyBAvI,OAAOC,OAAP,GAAiBiC,YAAjB,C;;;;;;AC9CA,iC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ead21ce95d5b7b27d643","/**\n * Database setup is done here\n */\nconst fs = require('fs');\nconst path = require('path');\nconst IS_PROD = !process.env.FORCE_DEV && process.env.NODE_ENV === 'production';\n\nconst DEFAULT_CONFIG = {\n  db: 'spectrum',\n};\n\nconst PRODUCTION_CONFIG = {\n  password: process.env.COMPOSE_RETHINKDB_PASSWORD,\n  host: process.env.COMPOSE_RETHINKDB_URL,\n  port: process.env.COMPOSE_RETHINKDB_PORT,\n  ssl: {\n    ca: IS_PROD && require('raw-loader!../../cacert'),\n  },\n};\n\nconst config = IS_PROD\n  ? {\n      ...DEFAULT_CONFIG,\n      ...PRODUCTION_CONFIG,\n    }\n  : {\n      ...DEFAULT_CONFIG,\n    };\n\nvar r = require('rethinkdbdash')(config);\n\nmodule.exports = { db: r };\n\n// /**\n//  * Database setup is done here\n//  */\n// const fs = require('fs');\n// const path = require('path');\n// const IS_PROD = !process.env.FORCE_DEV && process.env.NODE_ENV === 'production';\n//\n// const DEFAULT_CONFIG = {\n//   db: 'spectrum',\n// };\n//\n// // COMPOSE_RETHINKDB_URL=\"aws-us-east-1-portal.6.dblayer.com\"\n// // COMPOSE_RETHINKDB_PORT=19241\n// // COMPOSE_RETHINKDB_PASSWORD=\"12460d0b-b1dc-4505-9cd5-7a96e58ad825\"\n//\n// const PRODUCTION_CONFIG = {\n//   password: \"12460d0b-b1dc-4505-9cd5-7a96e58ad825\",\n//   host: \"aws-us-east-1-portal.6.dblayer.com\"  ,\n//   port: 19241,\n//   ssl: {\n//     ca: !IS_PROD && require('raw-loader!../../cacert'),\n//   },\n// };\n//\n// const config = !IS_PROD\n//   ? {\n//       ...DEFAULT_CONFIG,\n//       ...PRODUCTION_CONFIG,\n//     }\n//   : {\n//       ...DEFAULT_CONFIG,\n//     };\n//\n// var r = require('rethinkdbdash')(config);\n//\n// module.exports = { db: r };\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/db.js","// @flow\r\nconst Queue = require('bull');\r\nconst Raven = require('raven');\r\n\r\nif (process.env.NODE_ENV !== 'development') {\r\n  Raven.config(\r\n    'https://3bd8523edd5d43d7998f9b85562d6924:d391ea04b0dc45b28610e7fad735b0d0@sentry.io/154812',\r\n    {\r\n      environment: process.env.NODE_ENV,\r\n    }\r\n  ).install();\r\n}\r\n\r\nconst redis =\r\n  process.env.NODE_ENV === 'production'\r\n    ? {\r\n        port: process.env.COMPOSE_REDIS_PORT,\r\n        host: process.env.COMPOSE_REDIS_URL,\r\n        password: process.env.COMPOSE_REDIS_PASSWORD,\r\n      }\r\n    : undefined; // Use the local instance of Redis in development by not passing any connection string\r\n\r\n// Leave the options undefined if we're using the default redis connection\r\nconst options = redis && { redis: redis };\r\n\r\nfunction createQueue(name /*: string */) {\r\n  const queue = new Queue(name, options);\r\n  queue.on('stalled', job => {\r\n    const message = `Job#${job.id} stalled, processing again.`;\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.error(message);\r\n      return;\r\n    }\r\n    // In production log stalled job to Sentry\r\n    Raven.captureException(new Error(message));\r\n  });\r\n  return new Queue(name, options);\r\n}\r\n\r\nmodule.exports = createQueue;\r\n\n\n\n// WEBPACK FOOTER //\n// ./shared/bull/create-queue.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 2\n// module chunks = 0","module.exports = require(\"raven\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"raven\"\n// module id = 3\n// module chunks = 0","// @flow\n\n// counts for processing\n// the thread must have at least # total messages\nexport const MIN_TOTAL_MESSAGE_COUNT = 1;\n// # of the total messages must have been sent in the past week\nexport const MIN_NEW_MESSAGE_COUNT = 1;\n// # only show the top # threads per channel\nexport const MAX_THREAD_COUNT_PER_CHANNEL = 10;\n// don't send the digest if the email will have less than # total threads to show\nexport const MIN_THREADS_REQUIRED_FOR_DIGEST = 1;\n// cap the digest at # threads\nexport const MAX_THREAD_COUNT_PER_DIGEST = 10;\n// upsell communities to join if the user has joined less than # communities\nexport const COMMUNITY_UPSELL_THRESHOLD = 5;\n\n// generate a score for each thread based on the total number of messages and number of new messages\n// new messages rank higher in order to devalue old threads that have a large amount of old messages (like pinned posts)\n// the end weekly digest will have threads sorted by the weight of (TOTAL * WEIGHT) + (NEW * WEIGHT)\nexport const TOTAL_MESSAGE_COUNT_WEIGHT = 0.1;\nexport const NEW_MESSAGE_COUNT_WEIGHT = 1.5;\n\n/*\n  Example weighting:\n  A thread with 150 messages, where 5 are new this week: 22.5\n  A thread with 10 total messages, where all 10 are new this week: 16\n  A thread with 25 total messages, where 10 are old and 15 are new this week: 25\n*/\n\n// queues\nexport const SEND_WEEKLY_DIGEST_EMAIL = 'send weekly digest email';\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/queues/constants.js","// @flow\nconst debug = require('debug')('hermes');\nconst createWorker = require('../shared/bull/create-worker');\nimport processSendWeeklyDigestEmail from './queues/send-weekly-digest-email';\nimport { SEND_WEEKLY_DIGEST_EMAIL } from './queues/constants';\nimport { weeklyDigest } from './jobs';\n\nconst PORT = process.env.PORT || 3004;\n\nconsole.log('\\n✉️ Chronos, the cron job worker, is starting...');\ndebug('Logging with debug enabled!');\nconsole.log('');\n\nconst server = createWorker({\n  [SEND_WEEKLY_DIGEST_EMAIL]: processSendWeeklyDigestEmail,\n});\n\nconsole.log(\n  `🗄 Crons open for business ${(process.env.NODE_ENV === 'production' &&\n    `at ${process.env.COMPOSE_REDIS_URL}:${process.env.COMPOSE_REDIS_PORT}`) ||\n    'locally'}`\n);\n\nserver.listen(PORT, 'localhost', () => {\n  console.log(\n    `💉 Healthcheck server running at ${server.address()\n      .address}:${server.address().port}`\n  );\n});\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/index.js","// @flow\nconst debug = require('debug')('chronos:queue:send-weekly-digest-email');\n// $FlowFixMe\nimport intersection from 'lodash.intersection';\nimport createQueue from '../../shared/bull/create-queue';\nimport {\n  SEND_WEEKLY_DIGEST_EMAIL,\n  MIN_TOTAL_MESSAGE_COUNT,\n  MIN_NEW_MESSAGE_COUNT,\n  MAX_THREAD_COUNT_PER_CHANNEL,\n  MIN_THREADS_REQUIRED_FOR_DIGEST,\n  MAX_THREAD_COUNT_PER_DIGEST,\n  COMMUNITY_UPSELL_THRESHOLD,\n  TOTAL_MESSAGE_COUNT_WEIGHT,\n  NEW_MESSAGE_COUNT_WEIGHT,\n} from './constants';\nconst sendWeeklyDigestEmailQueue = createQueue(SEND_WEEKLY_DIGEST_EMAIL);\nimport { getActiveThreadsInPastWeek } from '../models/thread';\nimport { getUsersForWeeklyDigest } from '../models/usersSettings';\nimport { getUsersChannelsEligibleForWeeklyDigest } from '../models/usersChannels';\nimport { getUsersCommunityIds } from '../models/usersCommunities';\nimport { getTotalMessageCount, getNewMessageCount } from '../models/message';\nimport { getCommunityById, getTopCommunities } from '../models/community';\n\nexport default job => {\n  debug(`\\nnew job: ${job.id}`);\n  debug(`\\nprocessing weekly digest`);\n\n  /*\n      1. Get all threads in the database that were active in the last week. For each thread, construct a new object containing the thread data and the message count from the server\n  */\n  const allActiveThreadsThisWeek = async () => {\n    // returns array of thread ids\n    const threadIds = await getActiveThreadsInPastWeek();\n    debug('\\n ⚙️ Fetched all active threads this week');\n\n    // if no threadIds, escape\n    if (!threadIds || threadIds.length === 0) {\n      debug('\\n ❌  No active threads found');\n      return;\n    }\n\n    // for each thread that was active in the last week, return a new array containing a record for each thread with the thread data and the message count\n    const messageCountPromises = threadIds.map(\n      async ({ communityId, channelId, id, content, ...thread }) => ({\n        communityId,\n        channelId,\n        id,\n        title: content.title,\n        newMessageCount: await getNewMessageCount(id),\n        totalMessageCount: await getTotalMessageCount(id),\n      })\n    );\n\n    // promise all the active threads and message counts\n    const messageCounts = await Promise.all(messageCountPromises);\n    debug('\\n ⚙️ Fetched message counts for threads');\n\n    // remove any threads where the total message count is less than 10\n    const filteredTopThreads = messageCounts\n      .filter(thread => thread.totalMessageCount >= MIN_TOTAL_MESSAGE_COUNT)\n      .filter(thread => thread.newMessageCount >= MIN_NEW_MESSAGE_COUNT);\n    debug('\\n ⚙️ Filtered threads with enough messages');\n\n    // returns an array of threads that are active in the last week and have the minimum required message count to be considered valuable\n    return filteredTopThreads;\n  };\n\n  /*\n      2. Given an array of all the active threads this week that contain the minimum message count required, we now aggregate them by the channel where they were posted.\n\n      The return value from this function is an object with keys representing channelIds and values representing an array of threads\n  */\n  const activeThreadsByChannel = async () => {\n    // get all the active threads from this week\n    const topThreads = await allActiveThreadsThisWeek();\n\n    // if no topThreads, escape\n    if (!topThreads || topThreads.length === 0) {\n      debug('\\n ❌  No topThreads found');\n      return;\n    }\n\n    // create an empty object for the final output\n    let obj = {};\n\n    const getCommunity = id => getCommunityById(id);\n\n    // for each thread, get the community data that we'll need when rendering an email\n    const topThreadsWithCommunityDataPromises = topThreads.map(async thread => {\n      const community = await getCommunity(thread.communityId);\n\n      // this is the final data we'll send to the email for each thread\n      const obj = {\n        community: {\n          name: community.name,\n          slug: community.slug,\n          profilePhoto: community.profilePhoto,\n        },\n        channelId: thread.channelId,\n        title: thread.title,\n        threadId: thread.id,\n        newMessageCount: thread.newMessageCount,\n        totalMessageCount: thread.totalMessageCount,\n      };\n      return obj;\n    });\n\n    const threadsWithCommunityData = await Promise.all(\n      topThreadsWithCommunityDataPromises\n    );\n    // for each of the active threads this week, determine if that that thread has been categorized yet into the new object. If so, push that thread into the array, otherwise create a new key/value pair in the object for the channel + thread\n    const finalThreads = threadsWithCommunityData.map(\n      thread =>\n        obj[thread.channelId]\n          ? (obj[thread.channelId] = [...obj[thread.channelId], { ...thread }])\n          : (obj[thread.channelId] = [{ ...thread }])\n    );\n\n    const finishedTopThreads = await Promise.all(finalThreads);\n    debug('\\n ⚙️ Organized top threads by channel');\n\n    // return the final object containing keys for channelIds, and arrays of threads for values\n    return obj;\n  };\n\n  /*\n      3. In this step we process and aggregate user settings, users channels, and the thread data fetched above\n\n      a. first, get all the userIds of people who have opted to receive a weekly digest\n      b. for each person, get an array of channelIds where that user is a member\n      c. determine if there is any overlap between the user's channels and the active threads from the past week. Note: this filters out people who are members of inactive communities, even if they are opted in to receive a weekly digest\n  */\n  const eligibleUsersForWeeklyDigest = async () => {\n    // get users who have opted to receive a weekly digest\n    const users = await getUsersForWeeklyDigest();\n    debug('\\n ⚙️ Fetched users who want to receive a weekly digest');\n\n    // for each user who wants a weekly digest, fetch an array of channelIds where they are a member\n    const channelConnectionPromises = users.map(\n      async ({ email, firstName, userId, ...user }) => {\n        return {\n          email,\n          name: firstName || null,\n          userId,\n          channels: await getUsersChannelsEligibleForWeeklyDigest(userId),\n        };\n      }\n    );\n\n    // fetch all usersChannels\n    const usersWithChannels = await Promise.all(channelConnectionPromises);\n    debug('\\n ⚙️ Fetched users eligible channels');\n\n    // get all the threads, organized by channel, in scope\n    const threadData = await activeThreadsByChannel();\n\n    // if no threads exist\n    if (!threadData) {\n      debug('\\n ❌  No threadData found');\n      return;\n    }\n\n    // get an array of all channels where there are active threads this week\n    const threadChannelKeys = Object.keys(threadData);\n\n    // for each user, determine the overlapping channels where they are a member and where active threads occurred this week\n    const getIntersectingChannels = usersWithChannels.map(e => {\n      return {\n        ...e,\n        channels: intersection(e.channels, threadChannelKeys),\n      };\n    });\n    debug(\n      '\\n ⚙️ Filtered intersecting channels between the user and the top threads this week'\n    );\n\n    // based on the intersecting channels, get the threads that could appear in the user's weekly digest\n    const rawThreadsForUsersEmail = getIntersectingChannels.map(e => {\n      let arr = [];\n      e.channels.map(c => arr.push(...threadData[c]));\n      return {\n        ...e,\n        threads: [...arr],\n      };\n    });\n    debug(\n      '\\n ⚙️ Fetched all the possible threads this user could receive in a weekly digest'\n    );\n\n    // if no rawThreadsForUsersEmail, escape\n    if (!rawThreadsForUsersEmail || rawThreadsForUsersEmail.length === 0) {\n      debug('\\n ❌  No rawThreads found');\n      return;\n    }\n\n    // we don't want to send a weekly digest to someone with only one thread for that week - so in this step we filter out any results where the thread count is less than the miminimum acceptable threshhold\n    const eligibleUsersForWeeklyDigest = rawThreadsForUsersEmail\n      .filter(user => user.threads.length > MIN_THREADS_REQUIRED_FOR_DIGEST)\n      // and finally, sort the user's threads in descending order by message count\n      .map(({ channels, ...user }) => {\n        // for each thread, assign a score based on the total message count and new message count\n        const threadsWithScores = user.threads.map(thread => ({\n          ...thread,\n          score:\n            thread.newMessageCount * NEW_MESSAGE_COUNT_WEIGHT +\n            thread.totalMessageCount * TOTAL_MESSAGE_COUNT_WEIGHT,\n        }));\n\n        return {\n          ...user,\n          threads: threadsWithScores\n            .sort((a, b) => b.score - a.score)\n            .slice(0, MAX_THREAD_COUNT_PER_DIGEST),\n        };\n      });\n\n    debug(\n      '\\n ⚙️ Filtered users who have enough threads to qualify for a weekly digest'\n    );\n\n    /*\n      The result of our operations so far has given us an array with the following shape:\n\n      [\n        {\n          userId: ID,\n          email: String,\n          name?: String // returns null if user doesn't have a first name\n          threads: [{ thread1 }, { thread2}, ... ]\n        }\n        ...\n      ]\n\n      Where a thread contains the following information:\n      {\n        communityId: ID,\n        channelId: ID,\n        id: ID,\n        title: String,\n        messageCount: Number\n      }\n    */\n    return eligibleUsersForWeeklyDigest;\n  };\n\n  const processSendWeeklyDigests = async () => {\n    const eligibleUsers = await eligibleUsersForWeeklyDigest();\n    debug('\\n ⚙️  Got eligible users');\n    const topCommunities = await getTopCommunities(20);\n    debug('\\n ⚙️  Got top communities');\n\n    // if no elegible users, escape\n    if (!eligibleUsers || eligibleUsers.length === 0) {\n      debug('\\n ❌  No eligible users');\n      return;\n    }\n\n    debug('\\n👉 Eligible users data');\n    debug(eligibleUsers);\n    debug('\\n👉 Example array of threads');\n    debug(eligibleUsers[0].threads);\n    debug('\\n👉 Example thread data for email');\n    debug(eligibleUsers[0].threads[0]);\n\n    const sendDigestPromises = topCommunities =>\n      eligibleUsers.map(async user => {\n        // see what communities the user is in. if they are a member of less than 3 communities, we will upsell communities to join in the weekly digest\n        const usersCommunityIds = await getUsersCommunityIds(user.userId);\n        debug('\\n ⚙️  Got users communities');\n        // if the user has joined less than three communities, take the top communities on Spectrum, remove any that the user has already joined, and slice the first 3 to send into the email template\n        const communities =\n          usersCommunityIds.length < COMMUNITY_UPSELL_THRESHOLD\n            ? topCommunities\n                .filter(\n                  community => usersCommunityIds.indexOf(community.id) <= -1\n                )\n                .slice(0, 3)\n            : null;\n\n        debug('\\n ⚙️  Processed community upsells for email digest');\n\n        return await sendWeeklyDigestEmailQueue.add({ ...user, communities });\n      });\n\n    return await Promise.all(sendDigestPromises(topCommunities));\n  };\n\n  return processSendWeeklyDigests()\n  .catch(err => {\n    debug('❌  Error sending weekly digest');\n    debug(err);\n    console.log('Error sending weekly digests: ', err);\n  });\n};\n\n// migration\n// r.db('spectrum')\n//   .table('usersSettings')\n//   .filter({userId: '01p2A7kDCWUjGj6zQLlMQUOSQL42'})\n//   .update({\n//     notifications: {\n//       types: {\n//         newMessageInThreads: {\n//          email: r.row('notifications')('types')('newMessageInThreads')(\n//            'email'\n//          ),\n//         },\n//         newThreadCreated: {\n//          email: r.row('notifications')('types')('newThreadCreated')(\n//            'email'\n//          ),\n//         },\n//         newDirectMessage: {\n//          email: r.row('notifications')('types')('newDirectMessage')(\n//            'email'\n//          ),\n//         },\n//         weeklyDigest: {\n//          email: true\n//         },\n//       },\n//     },\n//   })\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/queues/send-weekly-digest-email.js","module.exports = require(\"lodash.intersection\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash.intersection\"\n// module id = 8\n// module chunks = 0","module.exports = require(\"bull\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"bull\"\n// module id = 9\n// module chunks = 0","// @flow\nconst { db } = require('./db');\n\nexport const getActiveThreadsInPastWeek = (): Promise<Array<Object>> => {\n  return db\n    .table('threads')\n    .filter(\n      db.row('lastActive').during(\n        // Change this to 60*60*24*7 to get weekly active users\n        db.now().sub(60 * 60 * 24 * 7),\n        db.now()\n      )\n    )\n    .filter(thread => db.not(thread.hasFields('deletedAt')))\n    .run();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/thread.js","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 12\n// module chunks = 0","module.exports = \"-----BEGIN CERTIFICATE-----\\nMIIDbzCCAlegAwIBAgIEWRMkLjANBgkqhkiG9w0BAQ0FADA5MTcwNQYDVQQDDC5T\\ncGFjZSBQcm9ncmFtLTc5Njk3YmRkYTQxNTg3YjFmMzk4MzYxNDhlNmJjMTZhMB4X\\nDTE3MDUxMDE0MzExMFoXDTM3MDUxMDE0MDAwMFowOTE3MDUGA1UEAwwuU3BhY2Ug\\nUHJvZ3JhbS03OTY5N2JkZGE0MTU4N2IxZjM5ODM2MTQ4ZTZiYzE2YTCCASIwDQYJ\\nKoZIhvcNAQEBBQADggEPADCCAQoCggEBALwgqk6SZZah3eVlCvZ8sFHDaHPWekVt\\n1k3XAUkV+SrxijNGWNPnzkumXEd+qWYS9gYL9ak1otEjbxPR9B7+zBiPOFbwX1fE\\n5o97W0gxjwS8iJGL3brSmSuJAfqx3be3l2Da4tpdgmQgKVID3c7E4AVFdgh0snh5\\nNAChbx/BZXtCyJNk8gRR0G9tX01EtAumoRe3PkHs6CN0ObUNX7W9l1G6J5N00ECU\\nZBEcXIyQ/lNzpJrIzcBrZ75mocyCVkp5HINjs0mG+CrSgVzY5KMtWOPFlr1KuH9P\\nDXwYBDAKI3sKxj3Bgmwq1WtFbhTfuZkynxSZ0rgnr+aVFcszL2ZRVDMCAwEAAaN/\\nMH0wHQYDVR0OBBYEFIXsudbQwxml7S2NjYaFCcTs0meUMA4GA1UdDwEB/wQEAwIC\\nBDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TBAUwAwEB/zAf\\nBgNVHSMEGDAWgBSF7LnW0MMZpe0tjY2GhQnE7NJnlDANBgkqhkiG9w0BAQ0FAAOC\\nAQEAfjae2H+mdzABC9Kkh/tLUPKtGu1c3/3QSq4RTPyOAsCgmtWO2NSUcEI928eo\\n8EJvljx8Xo2vl3DbD9OmbWzPeUqQMm2Wsq98RB80KRvQAFSwOKMDqyv0+C/UGnnw\\nry3UMfTuY5Y2rRwsY4Z6FDPWnLJJKIa6aKutYo1pzkkvphtwq8lPQO2NW4uTrpjG\\nuhhH2cmtBUZRvRGIey29Z0TXufUNN6EAcbo0JxEuux6HotXbwI0wRwPmqHLNbSWw\\ngCd/pne0Pjryvw6XHzd4CQUsElWafmOf/+N760O1RCC/XCzOnsjUSLiAt9R7C/Ao\\niS3oQCP1KMbyfpulMFctZJR0kQ==\\n-----END CERTIFICATE-----\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/raw-loader!./cacert\n// module id = 13\n// module chunks = 0","module.exports = require(\"rethinkdbdash\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rethinkdbdash\"\n// module id = 14\n// module chunks = 0","// @flow\r\nconst { db } = require('./db');\r\n\r\nexport const getUsersForWeeklyDigest = (): Promise<Array<Object>> => {\r\n  return db\r\n    .table('usersSettings')\r\n    .filter(row =>\r\n      row('notifications')('types')('weeklyDigest')('email').eq(true)\r\n    )\r\n    .eqJoin('userId', db.table('users'))\r\n    .zip()\r\n    .pluck(['userId', 'email', 'firstName', 'name'])\r\n    .distinct()\r\n    .run();\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/usersSettings.js","// @flow\nconst { db } = require('./db');\n\nexport const getUsersChannelsEligibleForWeeklyDigest = (\n  userId: string\n): Promise<Array<string>> => {\n  return db\n    .table('usersChannels')\n    .getAll(userId, { index: 'userId' })\n    .filter({ isMember: true })\n    .map(row => row('channelId'))\n    .run();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/usersChannels.js","// @flow\nconst { db } = require('./db');\nconst debug = require('debug')('hermes:queue:send-weekly-digest-email');\n\nexport const getUsersCommunityIds = (\n  userId: string\n): Promise<Array<string>> => {\n  debug(userId);\n  return (\n    db\n      .table('usersCommunities')\n      .getAll(userId, { index: 'userId' })\n      .filter({ isMember: true })\n      .run()\n      // return an array of the userIds to be loaded by gql\n      .then(\n        communities =>\n          debug(communities) ||\n          communities.map(community => community.communityId)\n      )\n  );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/usersCommunities.js","// @flow\nconst { db } = require('./db');\n\nexport const getTotalMessageCount = (threadId: string): Promise<number> => {\n  return db\n    .table('messages')\n    .getAll(threadId, { index: 'threadId' })\n    .count()\n    .run();\n};\n\nexport const getNewMessageCount = (threadId: string): Promise<number> => {\n  return db\n    .table('messages')\n    .getAll(threadId, { index: 'threadId' })\n    .filter(\n      db.row('timestamp').during(\n        // only count messages sent in the past week\n        db.now().sub(60 * 60 * 24 * 7),\n        db.now()\n      )\n    )\n    .count()\n    .run();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/message.js","// @flow\nconst { db } = require('./db');\n\nexport const getCommunityById = (id: string): Promise<Object> => {\n  return db.table('communities').get(id).run();\n};\n\nexport const getTopCommunities = (amount: number): Array<Object> => {\n  return db\n    .table('communities')\n    .pluck('id')\n    .run()\n    .then(communities => communities.map(community => community.id))\n    .then(communityIds => {\n      return Promise.all(\n        communityIds.map(community => {\n          return db\n            .table('usersCommunities')\n            .getAll(community, { index: 'communityId' })\n            .filter({ isMember: true })\n            .count()\n            .run()\n            .then(count => {\n              return {\n                id: community,\n                count,\n              };\n            });\n        })\n      );\n    })\n    .then(data => {\n      let sortedCommunities = data\n        .sort((x, y) => {\n          return y.count - x.count;\n        })\n        .map(community => community.id)\n        .slice(0, amount);\n\n      return db\n        .table('communities')\n        .getAll(...sortedCommunities)\n        .filter(community => db.not(community.hasFields('deletedAt')))\n        .run();\n    });\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/models/community.js","// @flow\nimport { createJob } from './utils';\n\n// weekly digest\nconst weeklyDigest = createJob(\n  'send weekly digest email',\n  '01 * * * * *', // run every second\n  true\n);\n\nmodule.exports = {\n  weeklyDigest,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/jobs/index.js","// @flow\nconst CronJob = require('../node_modules/cron').CronJob;\nconst createQueue = require('../../shared/bull/create-queue');\nimport Raven from 'raven';\n\n// logging to Sentry for weekly digests\nif (process.env.NODE_ENV !== 'development') {\n  Raven.config(\n    'https://3bd8523edd5d43d7998f9b85562d6924:d391ea04b0dc45b28610e7fad735b0d0@sentry.io/154812',\n    {\n      environment: process.env.NODE_ENV,\n    }\n  ).install();\n}\n\nexport const addQueue = (name: string, data: any, opts: any) => {\n  const worker = createQueue(name);\n  return worker.add({ ...data }, { ...opts }).catch(err => Raven.captureException(err));\n};\n\nexport const createJob = (\n  name: string, // name of the queue the cron job should trigger\n  pattern: string, // cron pattern\n  start: boolean // start immediately\n) => {\n  try {\n    const job = new CronJob({\n      cronTime: pattern,\n      onTick: () => {\n        console.log('🕑 New cron job initiated');\n        return addQueue(\n          name,\n          {},\n          { removeOnComplete: true, removeOnFail: true }\n        );\n      },\n      start,\n      timeZone: 'America/Los_Angeles',\n    });\n\n    return job.start();\n  } catch (err) {\n    console.log('❌ Error processing cron job:\\n' + err);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./chronos/jobs/utils.js","(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(['moment-timezone'], factory);\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory(require('moment-timezone'), require('child_process'));\n\t} else {\n\t\troot.Cron = factory(root.moment);\n\t}\n}(this, function (moment, child_process) {\n\nvar exports = {},\n\t\ttimeUnits = ['second', 'minute', 'hour', 'dayOfMonth', 'month', 'dayOfWeek'],\n\t\tspawn = child_process && child_process.spawn;\n\nfunction CronTime(source, zone) {\n\tthis.source = source;\n\n\tif (zone) {\n\t\tif (moment.tz.names().indexOf(zone) === -1) {\n\t\t\tthrow new Error('Invalid timezone.');\n\t\t}\n\n\t\tthis.zone = zone;\n\t}\n\n\tvar that = this;\n\ttimeUnits.map(function(timeUnit){\n\t\tthat[timeUnit] = {};\n\t});\n\n\tif (this.source instanceof Date) {\n\t\tthis.source = moment(this.source);\n\t\tthis.realDate = true;\n\t} else {\n\t\tthis._parse();\n\t\tthis._verifyParse();\n\t}\n}\n\nCronTime.constraints = [\n\t\t[0, 59],\n\t\t[0, 59],\n\t\t[0, 23],\n\t\t[1, 31],\n\t\t[0, 11],\n\t\t[0, 6]\n\t];\n\tCronTime.monthConstraints = [\n\t\t31,\n\t\t29, //support leap year...not perfect\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t31,\n\t\t30,\n\t\t31,\n\t\t30,\n\t\t31\n\t];\n\tCronTime.parseDefaults = ['0', '*', '*', '*', '*', '*'];\n\tCronTime.aliases = {\n\t\tjan: 0,\n\t\tfeb: 1,\n\t\tmar: 2,\n\t\tapr: 3,\n\t\tmay: 4,\n\t\tjun: 5,\n\t\tjul: 6,\n\t\taug: 7,\n\t\tsep: 8,\n\t\toct: 9,\n\t\tnov: 10,\n\t\tdec: 11,\n\t\tsun: 0,\n\t\tmon: 1,\n\t\ttue: 2,\n\t\twed: 3,\n\t\tthu: 4,\n\t\tfri: 5,\n\t\tsat: 6\n\t};\n\n\nCronTime.prototype = {\n\t_verifyParse: function() {\n\t\tvar months = Object.keys(this.month);\n\t\tfor (var i = 0; i < months.length; i++) {\n\t\t\tvar m = months[i];\n\t\t\tvar con = CronTime.monthConstraints[parseInt(m, 10)];\n\t\t\tvar ok = false;\n\t\t\tvar dsom = Object.keys(this.dayOfMonth);\n\t\t\tfor (var j = 0; j < dsom.length; j++) {\n\t\t\t\tvar dom = dsom[j];\n\t\t\t\tif (dom <= con)\n\t\t\t\t\tok = true;\n\t\t\t}\n\n\t\t\tif (!ok) {\n\t\t\t\tconsole.warn('Month \\'' + m + '\\' is limited to \\'' + con + '\\' days.');\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * calculates the next send time\n\t */\n\tsendAt: function(i) {\n\t\tvar date = this.realDate ? this.source : moment();\n\t\t// Set the timezone if given (http://momentjs.com/timezone/docs/#/using-timezones/parsing-in-zone/)\n\t\tif (this.zone)\n\t\t\tdate = date.tz(this.zone);\n\n\t\tif (this.realDate)\n\t\t\treturn date;\n\n\t\t//add 1 second so next time isn't now (can cause timeout to be 0 or negative number)\n\t\tvar now = new Date();\n\t\tvar targetSecond = date.seconds();\n\t\tvar diff = Math.abs(targetSecond - now.getSeconds())\n\t\t// there was a problem when `date` is 1424777177999 and `now` is 1424777178000\n\t\t// 1 ms diff but this is another second...\n\t\tif ( diff == 0 || (diff == 1 && now.getMilliseconds() <= date.milliseconds() ) ) {\n\t\t\t//console.log('add 1 second?');\n\t\t\tdate = date.add(1, 's');\n\t\t}\n\n\t\t//If the i argument is not given, return the next send time\n\t\tif(isNaN(i) || i < 0){\n\t\t\tdate = this._getNextDateFrom(date);\n\t\t\treturn date;\n\t\t}\n\t\t//Else return the next i send times\n\t\telse{\n\t\t\tvar dates = [];\n\t\t\tfor(;i>0;i--){\n\t\t\t\tdate = this._getNextDateFrom(date);\n\t\t\t\tdates.push(moment(date));\n\t\t\t\tif(i>1) date.add(1,'s');\n\t\t\t}\n\t\t\treturn dates;\n\t\t}\n\t},\n\n\t/**\n\t * Get the number of milliseconds in the future at which to fire our callbacks.\n\t */\n\tgetTimeout: function() {\n\t\treturn Math.max(-1, this.sendAt() - moment());\n\t},\n\n\t/**\n\t * writes out a cron string\n\t */\n\ttoString: function() {\n\t\treturn this.toJSON().join(' ');\n\t},\n\n\t/**\n\t * Json representation of the parsed cron syntax.\n\t */\n\ttoJSON: function() {\n\t\tvar self = this;\n\t\treturn timeUnits.map(function(timeName){\n\t\t\treturn self._wcOrAll(timeName);\n\t\t});\n\t},\n\n\t/**\n\t * get next date that matches parsed cron time\n\t */\n\t_getNextDateFrom: function(start) {\n\t\tvar date = moment(start);\n\t\tif (date.toString() == 'Invalid date') {\n\t\t\tconsole.log('ERROR: You specified an invalid date.');\n\t\t\treturn date;\n\t\t}\n\t\tif (this.realDate && start < new Date())\n\t\t\tconsole.log('WARNING: Date in past. Will never be fired.');\n\t\tif (this.realDate) return date;\n\n\t\t//sanity check\n\t\twhile (true) {\n\t\t\tvar diff = date - start,\n\t\t\t\torigDate = new Date(date);\n\n\t\t\tif (!(date.month() in this.month)) {\n\t\t\t\tdate.add(1, 'M');\n\t\t\t\tdate.date(1);\n\t\t\t\tdate.hours(0);\n\t\t\t\tdate.minutes(0);\n\t\t\t\tdate.seconds(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.date() in this.dayOfMonth)) {\n\t\t\t\tdate.add(1, 'd');\n\t\t\t\tdate.hours(0);\n\t\t\t\tdate.minutes(0);\n\t\t\t\tdate.seconds(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.day() in this.dayOfWeek)) {\n\t\t\t\tdate.add(1, 'd');\n\t\t\t\tdate.hours(0);\n\t\t\t\tdate.minutes(0);\n\t\t\t\tdate.seconds(0);\n\t\t\t\tif (date <= origDate) {\n\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.hours() in this.hour)) {\n\t\t\t\torigDate = moment(date);\n\t\t\t\tdate.hours(date.hours() == 23 && diff > 86400000 ? 0 : date.hours() + 1);\n\t\t\t\tdate.minutes(0);\n\t\t\t\tdate.seconds(0);\n\t\t\t\tif (date <= origDate) {\n\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.minutes() in this.minute)) {\n\t\t\t\torigDate = moment(date);\n\t\t\t\tdate.minutes(date.minutes() == 59 && diff > 60 * 60 * 1000 ? 0 : date.minutes() + 1);\n\t\t\t\tdate.seconds(0);\n\t\t\t\tif (date <= origDate) {\n\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!(date.seconds() in this.second)) {\n\t\t\t\torigDate = moment(date);\n\t\t\t\tdate.seconds(date.seconds() == 59 && diff > 60 * 1000 ? 0 : date.seconds() + 1);\n\t\t\t\tif (date <= origDate) {\n\t\t\t\t\tdate = this._findDST(origDate);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn date;\n\t},\n\n\t/**\n\t * get next date that is a valid DST date\n\t */\n\t_findDST: function(date) {\n\t\tvar newDate = moment(date);\n\t\twhile (newDate <= date)\n\t\t\tnewDate.add(1, 's');\n\n\t\treturn newDate;\n\t},\n\n\t/**\n\t * wildcard, or all params in array (for to string)\n\t */\n\t_wcOrAll: function(type) {\n\t\tif (this._hasAll(type)) return '*';\n\n\t\tvar all = [];\n\t\tfor (var time in this[type]) {\n\t\t\tall.push(time);\n\t\t}\n\n\t\treturn all.join(',');\n\t},\n\n\t_hasAll: function(type) {\n\t\tvar constrain = CronTime.constraints[timeUnits.indexOf(type)];\n\n\t\tfor (var i = constrain[0], n = constrain[1]; i < n; i++) {\n\t\t\tif (!(i in this[type])) return false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\n\t_parse: function() {\n\t\tvar aliases = CronTime.aliases,\n\t\tsource = this.source.replace(/[a-z]{1,3}/ig, function(alias) {\n\t\t\talias = alias.toLowerCase();\n\n\t\t\tif (alias in aliases) {\n\t\t\t\treturn aliases[alias];\n\t\t\t}\n\n\t\t\tthrow new Error('Unknown alias: ' + alias);\n\t\t}),\n\t\tsplit = source.replace(/^\\s\\s*|\\s\\s*$/g, '').split(/\\s+/),\n\t\tcur, i = 0,\n\t\tlen = timeUnits.length;\n\n\t\tfor (; i < timeUnits.length; i++) {\n\t\t\t// If the split source string doesn't contain all digits,\n\t\t\t// assume defaults for first n missing digits.\n\t\t\t// This adds support for 5-digit standard cron syntax\n\t\t\tcur = split[i - (len - split.length)] || CronTime.parseDefaults[i];\n\t\t\tthis._parseField(cur, timeUnits[i], CronTime.constraints[i]);\n\t\t}\n\t},\n\n\t_parseField: function(field, type, constraints) {\n\t\tvar rangePattern = /^(\\d+)(?:-(\\d+))?(?:\\/(\\d+))?$/g,\n\t\ttypeObj = this[type],\n\t\tpointer,\n\t\tlow = constraints[0],\n\t\thigh = constraints[1];\n\n\t\t// * is a shortcut to [lower-upper] range\n\t\tfield = field.replace(/\\*/g, low + '-' + high);\n\n\t\t//commas separate information, so split based on those\n\t\tvar allRanges = field.split(',');\n\n\t\tfor (var i = 0; i < allRanges.length; i++) {\n\t\t\tif (allRanges[i].match(rangePattern)) {\n\t\t\t\tallRanges[i].replace(rangePattern, function($0, lower, upper, step) {\n\t\t\t\t\tstep = parseInt(step) || 1;\n\t\t\t\t\t// Positive integer higher than constraints[0]\n\t\t\t\t\tlower = Math.min(Math.max(low, ~~Math.abs(lower)), high);\n\n\t\t\t\t\t// Positive integer lower than constraints[1]\n\t\t\t\t\tupper = upper ? Math.min(high, ~~Math.abs(upper)) : lower;\n\n\t\t\t\t\t// Count from the lower barrier to the upper\n\t\t\t\t\tpointer = lower;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\ttypeObj[pointer] = true\n\t\t\t\t\t\tpointer += step;\n\t\t\t\t\t} while (pointer <= upper);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthrow new Error('Field (' + field + ') cannot be parsed');\n\t\t\t}\n\t\t}\n\t}\n};\n\nfunction command2function(cmd) {\n\tvar command, args;\n\tswitch (typeof cmd) {\n\t\tcase 'string':\n\t\t\targs = cmd.split(' ');\n\t\t\tcommand = args.shift();\n\n\t\t\tcmd = spawn.bind(undefined, command, args);\n\t\t\tbreak;\n\t\tcase 'object':\n\t\t\tcommand = cmd && cmd.command;\n\t\t\tif (command) {\n\t\t\t\targs = cmd.args;\n\t\t\t\tvar options = cmd.options;\n\n\t\t\t\tcmd = spawn.bind(undefined, command, args, options);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn cmd\n}\n\nfunction CronJob(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit) {\n\tvar _cronTime = cronTime;\n\tif (typeof cronTime != 'string' && arguments.length == 1) {\n\t\t//crontime is an object...\n\t\tonTick = cronTime.onTick;\n\t\tonComplete = cronTime.onComplete;\n\t\tcontext = cronTime.context;\n\t\tstartNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n\t\ttimeZone = cronTime.timeZone;\n\t\trunOnInit = cronTime.runOnInit;\n\t\t_cronTime = cronTime.cronTime;\n\t}\n\n\tthis.context = (context || this);\n\tthis._callbacks = [];\n\tthis.onComplete = command2function(onComplete);\n\tthis.cronTime = new CronTime(_cronTime, timeZone);\n\n\taddCallback.call(this, command2function(onTick));\n\n\tif (runOnInit) fireOnTick.call(this);\n\tif (startNow) start.call(this);\n\n\treturn this;\n}\n\nvar addCallback = function(callback) {\n\tif (typeof callback == 'function') this._callbacks.push(callback);\n}\nCronJob.prototype.addCallback = addCallback;\n\nCronJob.prototype.setTime = function(time) {\n\tif (!(time instanceof CronTime)) throw new Error('\\'time\\' must be an instance of CronTime.');\n\tthis.stop();\n\tthis.cronTime = time;\n}\n\nCronJob.prototype.nextDate = function() {\n\treturn this.cronTime.sendAt();\n}\n\nvar fireOnTick = function() {\n\tfor (var i = (this._callbacks.length - 1); i >= 0; i--)\n\t\tthis._callbacks[i].call(this.context, this.onComplete);\n}\nCronJob.prototype.fireOnTick = fireOnTick;\n\nCronJob.prototype.nextDates = function(i) {\n\treturn this.cronTime.sendAt(i);\n}\n\nvar start = function() {\n\tif (this.running) return;\n\n\tvar MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n\tvar self = this;\n\tvar timeout = this.cronTime.getTimeout();\n\tvar remaining = 0;\n\tvar startTime;\n\n\tif (this.cronTime.realDate) this.runOnce = true;\n\n\tfunction _setTimeout(timeout) {\n\t\tstartTime = Date.now();\n\t\tself._timeout = setTimeout(callbackWrapper, timeout);\n\t}\n\n\t// The callback wrapper checks if it needs to sleep another period or not\n\t// and does the real callback logic when it's time.\n\n\tfunction callbackWrapper() {\n\t\tvar diff = startTime + timeout - Date.now();\n\n\t\tif (diff > 0) {\n\t\t\tvar newTimeout = self.cronTime.getTimeout();\n\n\t\t\tif (newTimeout > diff) {\n\t\t\t\tnewTimeout = diff;\n\t\t\t}\n\n\t\t\tremaining += newTimeout;\n\t\t}\n\n\t\t// If there is sleep time remaining, calculate how long and go to sleep\n\t\t// again. This processing might make us miss the deadline by a few ms\n\t\t// times the number of sleep sessions. Given a MAXDELAY of almost a\n\t\t// month, this should be no issue.\n\n\t\tself.lastExecution = new Date();\n\t\tif (remaining) {\n\t\t\tif (remaining > MAXDELAY) {\n\t\t\t\tremaining -= MAXDELAY;\n\t\t\t\ttimeout = MAXDELAY;\n\t\t\t} else {\n\t\t\t\ttimeout = remaining;\n\t\t\t\tremaining = 0;\n\t\t\t}\n\n\t\t\t_setTimeout(timeout);\n\t\t} else {\n\n\t\t\t// We have arrived at the correct point in time.\n\n\t\t\tself.running = false;\n\n\t\t\t//start before calling back so the callbacks have the ability to stop the cron job\n\t\t\tif (!(self.runOnce)) self.start();\n\n\t\t\tself.fireOnTick();\n\t\t\t//for (var i = (self._callbacks.length - 1); i >= 0; i--)\n\t\t\t\t//self._callbacks[i].call(self.context, self.onComplete);\n\t\t}\n\t}\n\n\tif (timeout >= 0) {\n\t\tthis.running = true;\n\n\t\t// Don't try to sleep more than MAXDELAY ms at a time.\n\n\t\tif (timeout > MAXDELAY) {\n\t\t\tremaining = timeout - MAXDELAY;\n\t\t\ttimeout = MAXDELAY;\n\t\t}\n\n\t\t_setTimeout(timeout);\n\t} else {\n\t\tthis.stop();\n\t}\n}\n\nCronJob.prototype.start = start;\n\nCronJob.prototype.lastDate = function(){\n\treturn this.lastExecution;\n};\n\n/**\n * Stop the cronjob.\n */\nCronJob.prototype.stop = function() {\n\tif (this._timeout)\n\t\tclearTimeout(this._timeout);\n\tthis.running = false;\n\tif (typeof this.onComplete == 'function') this.onComplete();\n}\n\nexports.job = function(cronTime, onTick, onComplete) {\n\treturn new CronJob(cronTime, onTick, onComplete);\n}\n\nexports.time = function(cronTime, timeZone) {\n\treturn new CronTime(cronTime, timeZone);\n}\n\nexports.sendAt = function(cronTime) {\n\treturn exports.time(cronTime).sendAt();\n}\n\nexports.timeout = function(cronTime) {\n\treturn exports.time(cronTime).getTimeout();\n}\n\nexports.CronJob = CronJob;\nexports.CronTime = CronTime;\n\nreturn exports;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./chronos/node_modules/cron/lib/cron.js\n// module id = 22\n// module chunks = 0","module.exports = require(\"moment-timezone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"moment-timezone\"\n// module id = 23\n// module chunks = 0","// @flow\r\n// Create a worker with bull and start a small webserver which responds with\r\n// health information\r\nconst http = require('http');\r\nconst createQueue = require('./create-queue');\r\n\r\n/*::\r\ntype QueueMap = {\r\n  [name: string]: (job: any) => Promise<any>\r\n}\r\n*/\r\n\r\n// Helper function to sum properties of an array of objects\r\n// e.g. [{ completed: 6 }, { completed: 2 }] => 8\r\nconst sumArr = (\r\n  input /*: Array<Object> */,\r\n  prop /*: string */ /*: number */\r\n) => {\r\n  return input.reduce((sum, item) => sum + item[prop], 0);\r\n};\r\n\r\nconst createWorker = (queueMap /*: QueueMap */) => {\r\n  // Start processing the queues\r\n  const queues = Object.keys(queueMap).map(name => {\r\n    const queue = createQueue(name);\r\n    queue.process(queueMap[name]);\r\n    return queue;\r\n  });\r\n\r\n  return http.createServer((req, res) => {\r\n    res.setHeader('Content-Type', 'application/json');\r\n    // Summarize the data across all the queues\r\n    Promise.all(queues.map(queue => queue.getJobCounts())).then(jobCounts => {\r\n      const data = {\r\n        waiting: sumArr(jobCounts, 'waiting'),\r\n        active: sumArr(jobCounts, 'active'),\r\n        completed: sumArr(jobCounts, 'completed'),\r\n        failed: sumArr(jobCounts, 'failed'),\r\n        delayed: sumArr(jobCounts, 'delayed'),\r\n      };\r\n\r\n      res.end(JSON.stringify(data, null, 2));\r\n    });\r\n  });\r\n};\r\n\r\nmodule.exports = createWorker;\r\n\n\n\n// WEBPACK FOOTER //\n// ./shared/bull/create-worker.js","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 25\n// module chunks = 0"],"sourceRoot":""}